webpackJsonp([13],{790:function(t,n,e){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}function s(t){return w.default.createElement(t.tag,(0,b.default)({},t.attributes,{dangerouslySetInnerHTML:{__html:t.html}}))}function l(t){return w.default.createElement(s,{tag:"section",html:t.html})}function d(t){return w.default.createElement(s,{tag:"style",html:t.style})}var o=e(1),c=a(o),r=e(2),h=a(r),p=e(5),i=a(p),m=e(4),u=a(m),f=e(3),g=a(f),j=e(12),b=a(j),y=e(0),w=a(y),_=e(177),z=function(){return w.default.createElement("div",{className:"zent-doc-portal-container"},w.default.createElement("div",{className:"zent-doc-portal-mount-node"},"这里是原来就有的内容"),w.default.createElement(_.Portal,{selector:".zent-doc-portal-mount-node"},w.default.createElement("div",{className:"zent-doc-portal-content"},"这里是 Portal 动态插入的内容")))}(),v=function(t){function n(){var t,e,a,s;(0,h.default)(this,n);for(var l=arguments.length,d=Array(l),o=0;o<l;o++)d[o]=arguments[o];return e=a=(0,u.default)(this,(t=n.__proto__||(0,c.default)(n)).call.apply(t,[this].concat(d))),a.state={showCode:!0},a.toggle=function(){a.setState({showCode:!a.state.showCode})},s=e,(0,u.default)(a,s)}return(0,g.default)(n,t),(0,i.default)(n,[{key:"render",value:function(){var t=this.state.showCode,n=this.props,e=n.title,a=n.src,l=n.demo;return w.default.createElement("div",{className:"zandoc-react-demo"},w.default.createElement("div",{className:"zandoc-react-demo__preview"},l),w.default.createElement("div",{className:"zandoc-react-demo__bottom",onClick:this.toggle},w.default.createElement("i",{className:"zenticon zenticon-right zandoc-react-demo__toggle "+(t?"zandoc-react-demo__toggle-on":"zandoc-react-demo__toggle-off")}),w.default.createElement(s,{tag:"div",attributes:{className:"zandoc-react-demo__title"},html:e})),t&&w.default.createElement(s,{tag:"pre",html:a,attributes:{className:"zandoc-react-demo__code"}}))}}]),n}(y.Component);t.exports=function(t){function n(){return(0,h.default)(this,n),(0,u.default)(this,(n.__proto__||(0,c.default)(n)).apply(this,arguments))}return(0,g.default)(n,t),(0,i.default)(n,[{key:"render",value:function(){return w.default.createElement("div",{className:"zandoc-react-container "},w.default.createElement(d,{style:""}),w.default.createElement(l,{html:'<h2 id="portal -chuan-song-men"><a href="#portal%20-chuan-song-men">¶</a>Portal 传送门</h2>\n<p>传送门组件。</p>\n<h3 id="shi-yong-chang-jing"><a href="#shi-yong-chang-jing">¶</a>使用场景</h3>\n<p>这个组件不提供样式，但它是所有弹层组件的基石。使用 <code>Portal</code> 的好处是不需要自己管理动态插入的节点，防止内存泄露。</p>\n<h3 id="dai-ma-yan-shi"><a href="#dai-ma-yan-shi">¶</a>代码演示</h3>'}),w.default.createElement(v,{title:"<p>基本用法，第二行是 <code>Portal</code> 插入的，可以在浏览器里审查元素观察Html结构</p>",src:'<span class="hljs-keyword">import</span> { Portal } <span class="hljs-keyword">from</span> <span class="hljs-string">\'zent\'</span>;\n\nReactDOM.render(\n  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"zent-doc-portal-container"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"zent-doc-portal-mount-node"</span>&gt;</span>这里是原来就有的内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">Portal</span> <span class="hljs-attr">selector</span>=<span class="hljs-string">".zent-doc-portal-mount-node"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"zent-doc-portal-content"</span>&gt;</span>这里是 Portal 动态插入的内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Portal</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  , mountNode\n);',demo:z}),w.default.createElement(l,{html:'<h3 id="api"><a href="#api">¶</a>API</h3>\n<table class="table">\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>类型</th>\n<th>默认值</th>\n<th>备选值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>children</td>\n<td>必填参数, 只支持一个child</td>\n<td>string</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>selector</td>\n<td>可选参数, 渲染child的DOM节点</td>\n<td>string or DOM Element</td>\n<td><code>\'body\'</code></td>\n<td>合法的CSS selector或者某个DOM节点</td>\n</tr>\n<tr>\n<td>visible</td>\n<td>可选参数, 是否渲染child</td>\n<td>bool</td>\n<td><code>true</code></td>\n<td></td>\n</tr>\n<tr>\n<td>className</td>\n<td>可选参数, 自定义额外类名</td>\n<td>string</td>\n<td><code>\'\'</code></td>\n<td></td>\n</tr>\n<tr>\n<td>css</td>\n<td>可选参数, 额外的css样式. 例如, \n<code>{ \'margin-left\': \'10px\' }</code></td>\n<td>object</td>\n<td><code>{}</code></td>\n<td></td>\n</tr>\n<tr>\n<td>prefix</td>\n<td>可选参数, 自定义前缀</td>\n<td>string</td>\n<td><code>\'zent\'</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><code>Portal</code> 另外还提供了几个高阶组件(HOC)，提供了一些弹层常用的逻辑。</p>\n<h4 id="withesctoclose"><a href="#withesctoclose">¶</a>withESCToClose</h4>\n<p>封装了按ESC关闭的逻辑.</p>\n<table class="table">\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>visible</td>\n<td>必填参数, 注意这个属性原始的Portal是可选的</td>\n<td>bool</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td>onClose</td>\n<td>必填参数, ESC按下是的回调函数</td>\n<td>func</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<pre><code class="hljs js"><span class="hljs-keyword">import</span> _Portal <span class="hljs-keyword">from</span> <span class="hljs-string">\'zent-portal\'</span>;\n<span class="hljs-keyword">import</span> { withESCToClose } <span class="hljs-keyword">from</span> <span class="hljs-string">\'zent-portal\'</span>;\n<span class="hljs-keyword">const</span> Portal = withESCToClose(_Portal);\n</code></pre>\n<h4 id="withnonscrollable"><a href="#withnonscrollable">¶</a>withNonScrollable</h4>\n<p>封装了禁止container滚动的逻辑.</p>\n<table class="table">\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>visible</td>\n<td>必填参数, 注意这个属性原始的Portal是可选的</td>\n<td>bool</td>\n<td><code>true</code></td>\n</tr>\n</tbody>\n</table>\n<pre><code class="hljs js"><span class="hljs-keyword">import</span> _Portal <span class="hljs-keyword">from</span> <span class="hljs-string">\'zent-portal\'</span>;\n<span class="hljs-keyword">import</span> { withNonScrollable } <span class="hljs-keyword">from</span> <span class="hljs-string">\'zent-portal\'</span>;\n<span class="hljs-keyword">const</span> Portal = withNonScrollable(_Portal);\n</code></pre>\n<h3 id="zu-jian-yuan-li"><a href="#zu-jian-yuan-li">¶</a>组件原理</h3>\n<ul>\n<li>组件的主要功能是把其 <code>child</code> 插入到一个给定的 DOM node中, 并且在组件被 <code>unmount</code> 的时候将其 <code>child</code> 属性对应的 DOM 节点删除.</li>\n<li>任意 props 被修改后会触发一定程度的重绘, <code>children</code>, <code>selector</code>被修改会导致组件 <code>unmount</code> 再 <code>mount</code>；其它props被修改仅更新现有 DOM node 的属性.</li>\n</ul>\n<h3 id="yi-zhi-wen-ti"><a href="#yi-zhi-wen-ti">¶</a>已知问题</h3>\n<ul>\n<li>\n<p>在 Portal 的 <code>children</code> 上使用字符串形式的 <code>ref</code> 会报错, 可以使用函数形式的 <code>ref</code> 绕过这个问题. 其原因是 Portal 的 <code>children</code> 没有owner, 使用函数形式的<code>ref</code>可以绕过这个问题的原因参见<a href="https://github.com/facebook/react/blob/v15.0.2/src/renderers/shared/reconciler/ReactRef.js#L18"> Here</a>. 此外官方也不鼓励使用字符串形式的 <code>ref</code>.</p>\n</li>\n<li>\n<p><code>15.0.2</code> 版本的 React 有个 bug 会导致某些情况下依赖 <code>state</code> 的 <code>context</code> 不更新 (参考 example: 02-context), 请等待 React 版本的统一升级.</p>\n</li>\n</ul>'}))}}]),n}(y.Component)}});